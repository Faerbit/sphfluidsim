#version 430

layout(local_size_x = $THREAD_SIZE, local_size_y = 1, local_size_z = 1) in;


layout(std430, binding = 0) buffer SortPositions {
    vec4 spos[];
} sortPositions;

layout(std430, binding = 1) buffer VoxelIndex {
    ivec2 ind[];
} voxelIndex;

layout(std430, binding = 2) buffer SortVelocities {
    vec4 svel[];
} sortVelocities;

layout(std430, binding = 3) buffer Positions {
    vec4 pos[];
} positions;

layout(std430, binding = 4) buffer Velocities {
    vec4 vel[];
} velocities;

// hacky work around because apparently simple uniforms are a thing of the
// devil
// data[0] = timeStep
// data[1] = randomNumber
layout(std430, binding = 5) buffer Data{
    float data[];
} data;

uniform int work_items;

const float domain_size_x = $DOMAIN_SIZE_X;
const float domain_size_y = $DOMAIN_SIZE_Y;
const float domain_size_z = $DOMAIN_SIZE_Z;
const float interaction_radius = $INTERACTION_RADIUS;
const int voxel_count_x = int(ceil(domain_size_x/interaction_radius));
const int voxel_count_y = int(ceil(domain_size_y/interaction_radius));
const int voxel_count_z = int(ceil(domain_size_z/interaction_radius));

const float particle_mass = $PARTICLE_MASS;
const float dynamic_viscosity = $DYNAMIC_VISCOSITY;
const float resting_density = $RESTING_DENSITY;
const float kinematic_viscosity = dynamic_viscosity/resting_density;
const float gravity = $GRAVITY;
const float pressure_factor = $PRESSURE_FACTOR;

const float PI = 3.14159265359;

int[$MAX_NO_INTERACT_PARTICLES] neighbourParts;
int found_neighbour_parts = 0;

void getNeighbourParts(vec4 self, int own_id) {
    // get voxel pos
    int voxel_id = int(self.w);
    int voxel_z_pos = int(voxel_id/(voxel_count_y * voxel_count_x));
    voxel_id = voxel_id % (voxel_count_y * voxel_count_x);
    int voxel_y_pos = int(voxel_id/voxel_count_x);
    voxel_id = voxel_id % voxel_count_x;
    int voxel_x_pos = voxel_id;
    
    // get neighbouring voxels
    int voxel_min_x_pos = max(0, voxel_x_pos - 1);
    int voxel_max_x_pos = min(voxel_count_x, voxel_x_pos + 1);

    int voxel_min_y_pos = max(0, voxel_y_pos - 1);
    int voxel_max_y_pos = min(voxel_count_y, voxel_y_pos + 1);

    int voxel_min_z_pos = max(0, voxel_z_pos - 1);
    int voxel_max_z_pos = min(voxel_count_z, voxel_z_pos + 1);
    int neighbour_voxel_count = (1+ voxel_max_x_pos - voxel_min_x_pos) *
        (1 + voxel_max_y_pos - voxel_min_y_pos) *
        (1 + voxel_max_z_pos - voxel_min_z_pos);
    int[27] neighbour_voxels;
    int ind = 0;
    for(int i = voxel_min_x_pos; i<=voxel_max_x_pos; i++) {
        for(int j = voxel_min_y_pos; j<=voxel_max_y_pos; j++) {
            for(int k = voxel_min_z_pos; k<=voxel_max_z_pos; k++) {
                neighbour_voxels[ind] = i
                    + j * voxel_count_x
                    + k * (voxel_count_x * voxel_count_y);
                ind++;
            }
        }
    }
    for(int i = neighbour_voxel_count; i<27; i++) {
        neighbour_voxels[i] = -1;
    }
    ivec4[27] partIndices;
    for(int i = 0; i<27; i++) {
        if (neighbour_voxels[i] > -1) {
            int _min = voxelIndex.ind[neighbour_voxels[i]].x;
            if (_min > -1) {
                int _max = voxelIndex.ind[neighbour_voxels[i]].y;
                // voxel start 
                partIndices[i].x = _min;
                // voxel length
                partIndices[i].y = _max - _min;
                // random offset into voxel
                // data.data[1]: random number from 0.0 to 1.0
                int rand_start = int(data.data[1] * (_max - _min));
                partIndices[i].z = rand_start;
                // to be able to detect, when we have searched every particle in
                // this voxel
                partIndices[i].w = rand_start;
            }
            else {
                partIndices[i] = ivec4(-1);
            }
        }
        else {
            partIndices[i] = ivec4(-1);
        }
    }
    found_neighbour_parts = 0;
    bool[27] voxels_to_search;
    for(int i = 0; i<27; i++) {
        voxels_to_search[i] = true;
    }
    while (found_neighbour_parts<32) {
        bool unsearched_voxels = false;
        for(int i= 0; i<27; i++) {
            if (voxels_to_search[i] == true) {
                unsearched_voxels = true;
                break;
            }
        }
        if (unsearched_voxels == false) {
            break;
        }
        for(int i = 0; i< 27; i++) {
            int part = partIndices[i].z;
            if (found_neighbour_parts < 32 && part > -1) {
                part = partIndices[i].x + partIndices[i].z;
                if (distance(vec3(self),
                        vec3(sortPositions.spos[part])) <= interaction_radius) {
                    if (own_id != part) {
                        neighbourParts[found_neighbour_parts] = part;
                        found_neighbour_parts++;
                    }
                }
                // alternate search direction per particel
                int direction = 1 -(2*(own_id%2));
                partIndices[i].z =
                    (partIndices[i].z + direction) % (partIndices[i].y + 1);
                if (partIndices[i].z == partIndices[i].w) {
                    partIndices[i].z = -1;
                }
            }
            else {
                // mark voxel as searched
                voxels_to_search[i] = false;
            }
        }
    }
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id <= work_items) {
        vec4 self_pos = sortPositions.spos[id];
        getNeighbourParts(self_pos, int(id));
        // physics formula from
        // "Smoothed Particle Hydrodynamics" OpenCL Programming Webinar Series
        // by AMD (November 29, 2019) Slide 14

        // condenses equations
        float h = interaction_radius;

        // compute density
        float density = 0.0;
        for(int i = 0; i<found_neighbour_parts; i++) {
            float _distance = distance(self_pos, sortPositions.spos[i]);
            density += particle_mass * (315/(64*PI* pow(h, 9)))
                * pow(pow(h, 2) - pow(_distance, 2), 3);
        }

        // compute pressure term
        float pressure = pressure_factor* (density - resting_density);
        vec3 pressure_gradient = vec3(0.0);
        for(int i = 0; i<found_neighbour_parts; i++) {
            //pressure_gradient += particle_mass * ((pressure
        }
    }
}
