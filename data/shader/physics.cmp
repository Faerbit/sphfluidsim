#version 430

layout(local_size_x = $THREAD_SIZE, local_size_y = 1, local_size_z = 1) in;


layout(std430, binding = 0) buffer SortPositions {
    vec4 spos[];
} sortPositions;

layout(std430, binding = 1) buffer VoxelIndex {
    ivec2 ind[];
} voxelIndex;

layout(std430, binding = 2) buffer SortVelocities {
    vec4 svel[];
} sortVelocities;

layout(std430, binding = 3) buffer Positions {
    vec4 pos[];
} positions;

layout(std430, binding = 4) buffer Velocities {
    vec4 vel[];
} velocities;

// hacky work around because apparently simple uniforms are a thing of the
// devil
// data[0] = timeStep
// data[1] = randomNumber
layout(std430, binding = 5) buffer Data{
    float data[];
} data;

uniform int work_items;

const float domain_size_x = $DOMAIN_SIZE_X;
const float domain_size_y = $DOMAIN_SIZE_Y;
const float domain_size_z = $DOMAIN_SIZE_Z;
const float interaction_radius = $INTERACTION_RADIUS;
const int voxel_count_x = int(ceil(domain_size_x/interaction_radius));
const int voxel_count_y = int(ceil(domain_size_y/interaction_radius));
const int voxel_count_z = int(ceil(domain_size_z/interaction_radius));

// TODO check if this is needed anywhere
//const int maxNoInteractParticles = $MAX_NO_INTERACT_PARTICLE;

const float particle_mass = $PARTICLE_MASS;
const float kinematic_viscosity = $KINEMATIC_VISCOSITY;
const float gravity = $GRAVITY;

int[$MAX_NO_INTERACT_PARTICLES] neighbourParts;

void getNeighbourParts(int id) {
    // get voxel pos
    int voxel_id = int(sortPositions.spos[id].w);
    int voxel_z_pos = int(voxel_id/(voxel_count_y * voxel_count_x));
    voxel_id = voxel_id % (voxel_count_y * voxel_count_x);
    int voxel_y_pos = int(voxel_id/voxel_count_x);
    voxel_id = voxel_id % voxel_count_x;
    int voxel_x_pos = voxel_id;
    
    // get neighbouring voxels
    int voxel_min_x_pos = max(0, voxel_x_pos - 1);
    int voxel_max_x_pos = min(voxel_count_x, voxel_x_pos + 1);

    int voxel_min_y_pos = max(0, voxel_y_pos - 1);
    int voxel_max_y_pos = min(voxel_count_y, voxel_y_pos + 1);

    int voxel_min_z_pos = max(0, voxel_z_pos - 1);
    int voxel_max_z_pos = min(voxel_count_z, voxel_z_pos + 1);
    int neighbour_voxel_count = (voxel_max_x_pos - voxel_min_x_pos) *
        (voxel_max_y_pos - voxel_max_y_pos) *
        (voxel_max_z_pos - voxel_min_z_pos);
    int[27] neighbour_voxels;
    int ind = 0;
    for(int i = voxel_min_x_pos; i<=voxel_max_x_pos; i++) {
        for(int j = voxel_min_y_pos; j<=voxel_max_y_pos; j++) {
            for(int k = voxel_min_z_pos; k<=voxel_max_z_pos; k++) {
                neighbour_voxels[ind] = i
                    + j * voxel_count_x
                    + k * (voxel_count_x * voxel_count_y);
                ind++;
            }
        }
    }
    // TODO temporary debug output
    for(int i=0; i<27; i++) {
        neighbourParts[i] = neighbour_voxels[i];
    }
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id <= work_items) {
        getNeighbourParts(int(id));
        // TODO temporary debug output
        for(int i=0; i<32; i++) {
            sortVelocities.svel[id*32 + i].x = float(neighbourParts[i]);
        }
    }
}
